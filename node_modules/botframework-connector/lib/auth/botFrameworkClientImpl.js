"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BotFrameworkClientImpl = void 0;
const z = require("zod");
const botframework_schema_1 = require("botframework-schema");
const conversationConstants_1 = require("../conversationConstants");
const connectorFactoryImpl_1 = require("./connectorFactoryImpl");
const core_http_1 = require("@azure/core-http");
const assert_1 = require("assert");
const axios_1 = require("axios");
const botFrameworkClientFetchImpl = (connectorClientOptions) => {
    var _a;
    const { http: httpAgent, https: httpsAgent } = (_a = connectorClientOptions === null || connectorClientOptions === void 0 ? void 0 : connectorClientOptions.agentSettings) !== null && _a !== void 0 ? _a : {
        http: undefined,
        https: undefined,
    };
    const axiosInstance = axios_1.default.create({
        httpAgent,
        httpsAgent,
        validateStatus: () => true,
    });
    return (input, init) => __awaiter(void 0, void 0, void 0, function* () {
        const url = z.string().parse(input);
        const { body, headers } = z.object({ body: z.string(), headers: z.record(z.string()).optional() }).parse(init);
        const response = yield axiosInstance.post(url, body, {
            headers,
        });
        return {
            status: response.status,
            json: () => response.data,
        };
    });
};
/**
 * @internal
 * Implementation of [BotFrameworkClient](xref:botframework-connector.BotFrameworkClient).
 */
class BotFrameworkClientImpl {
    /**
     * @param credentialsFactory A [ServiceClientCredentialsFactory](xref:botframework-connector.ServiceClientCredentialsFactory) instance.
     * @param loginEndpoint The login url.
     * @param botFrameworkClientFetch A custom Fetch implementation to be used in the [BotFrameworkClient](xref:botframework-connector.BotFrameworkClient).
     * @param connectorClientOptions  A [ConnectorClientOptions](xref:botframework-connector.ConnectorClientOptions) object.
     */
    constructor(credentialsFactory, loginEndpoint, botFrameworkClientFetch, connectorClientOptions) {
        var _a;
        this.credentialsFactory = credentialsFactory;
        this.loginEndpoint = loginEndpoint;
        this.botFrameworkClientFetch = botFrameworkClientFetch;
        this.connectorClientOptions = connectorClientOptions;
        (_a = this.botFrameworkClientFetch) !== null && _a !== void 0 ? _a : (this.botFrameworkClientFetch = botFrameworkClientFetchImpl(this.connectorClientOptions));
        (0, assert_1.ok)(typeof this.botFrameworkClientFetch === 'function');
    }
    toJSON() {
        // Ignore ConnectorClientOptions, as it could contain Circular Structure behavior.
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        const _a = this, { connectorClientOptions } = _a, rest = __rest(_a, ["connectorClientOptions"]);
        return rest;
    }
    /**
     * @template T The type of body in the InvokeResponse.
     * @param fromBotId The MicrosoftAppId of the bot sending the activity.
     * @param toBotId The MicrosoftAppId of the bot receiving the activity.
     * @param toUrl The URL of the bot receiving the activity.
     * @param serviceUrl The callback Url for the skill host.
     * @param conversationId A conversation ID to use for the conversation with the skill.
     * @param activity The Activity to send to forward.
     * @returns {Promise<InvokeResponse<T>>} A promise representing the asynchronous operation.
     */
    postActivity(fromBotId, toBotId, toUrl, serviceUrl, conversationId, activity) {
        return __awaiter(this, void 0, void 0, function* () {
            z.object({
                fromBotId: z.string().optional(),
                toBotId: z.string().optional(),
                toUrl: z.string(),
                serviceUrl: z.string(),
                conversationId: z.string(),
                activity: z.record(z.unknown()),
            }).parse({
                fromBotId,
                toBotId,
                toUrl,
                serviceUrl,
                conversationId,
                activity,
            });
            const credentials = yield this.credentialsFactory.createCredentials(fromBotId, toBotId, this.loginEndpoint, true);
            // Capture current activity settings before changing them.
            // TODO: DO we need to set the activity ID? (events that are created manually don't have it).
            const originalConversationId = activity.conversation.id;
            const originalServiceUrl = activity.serviceUrl;
            const originalRelatesTo = activity.relatesTo;
            const originalRecipient = activity.recipient;
            try {
                activity.relatesTo = {
                    serviceUrl: activity.serviceUrl,
                    activityId: activity.id,
                    channelId: activity.channelId,
                    conversation: {
                        id: activity.conversation.id,
                        name: activity.conversation.name,
                        conversationType: activity.conversation.conversationType,
                        aadObjectId: activity.conversation.aadObjectId,
                        isGroup: activity.conversation.isGroup,
                        properties: activity.conversation.properties,
                        role: activity.conversation.role,
                        tenantId: activity.conversation.tenantId,
                    },
                    bot: null,
                };
                activity.conversation.id = conversationId;
                activity.serviceUrl = serviceUrl;
                // Fixes: https://github.com/microsoft/botframework-sdk/issues/5785
                if (!activity.recipient) {
                    activity.recipient = {};
                }
                activity.recipient.role = botframework_schema_1.RoleTypes.Skill;
                const webRequest = new core_http_1.WebResource(toUrl, 'POST', JSON.stringify(activity), undefined, {
                    Accept: 'application/json',
                    [conversationConstants_1.ConversationIdHttpHeaderName]: conversationId,
                    'Content-Type': 'application/json',
                    'User-Agent': connectorFactoryImpl_1.USER_AGENT,
                });
                const request = yield credentials.signRequest(webRequest);
                const config = {
                    body: request.body,
                    headers: request.headers.rawHeaders(),
                };
                const response = yield this.botFrameworkClientFetch(request.url, config);
                return { status: response.status, body: yield response.json() };
            }
            finally {
                // Restore activity properties.
                activity.conversation.id = originalConversationId;
                activity.serviceUrl = originalServiceUrl;
                activity.relatesTo = originalRelatesTo;
                activity.recipient = originalRecipient;
            }
        });
    }
}
exports.BotFrameworkClientImpl = BotFrameworkClientImpl;
//# sourceMappingURL=botFrameworkClientImpl.js.map