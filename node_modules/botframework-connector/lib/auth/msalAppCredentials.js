"use strict";
/**
 * @module botframework-connector
 */
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MsalAppCredentials = void 0;
const msal_node_1 = require("@azure/msal-node");
const appCredentials_1 = require("./appCredentials");
/**
 * An implementation of AppCredentials that uses @azure/msal-node to fetch tokens.
 */
class MsalAppCredentials extends appCredentials_1.AppCredentials {
    /**
     * @internal
     */
    constructor(maybeClientApplicationOrAppId, maybeAppIdOrAppPasswordOrCertificate, maybeAuthority, maybeScope) {
        const appId = typeof maybeClientApplicationOrAppId === 'string'
            ? maybeClientApplicationOrAppId
            : typeof maybeAppIdOrAppPasswordOrCertificate === 'string'
                ? maybeAppIdOrAppPasswordOrCertificate
                : undefined;
        super(appId, undefined, maybeScope);
        if (typeof maybeClientApplicationOrAppId !== 'string') {
            this.clientApplication = maybeClientApplicationOrAppId;
        }
        else {
            const auth = {
                authority: maybeAuthority,
                clientId: appId,
            };
            auth.clientCertificate =
                typeof maybeAppIdOrAppPasswordOrCertificate !== 'string'
                    ? maybeAppIdOrAppPasswordOrCertificate
                    : undefined;
            auth.clientSecret =
                typeof maybeAppIdOrAppPasswordOrCertificate === 'string'
                    ? maybeAppIdOrAppPasswordOrCertificate
                    : undefined;
            this.clientApplication = new msal_node_1.ConfidentialClientApplication({ auth });
        }
    }
    /**
     * @inheritdoc
     */
    refreshToken() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.clientApplication) {
                throw new Error('getToken should not be called for empty credentials.');
            }
            const scopePostfix = '/.default';
            let scope = this.oAuthScope;
            if (!scope.endsWith(scopePostfix)) {
                scope = `${scope}${scopePostfix}`;
            }
            const token = yield this.clientApplication.acquireTokenByClientCredential({
                scopes: [scope],
                skipCache: true,
            });
            const { accessToken } = token !== null && token !== void 0 ? token : {};
            if (typeof accessToken !== 'string') {
                throw new Error('Authentication: No access token received from MSAL.');
            }
            return {
                accessToken: token.accessToken,
                expiresOn: token.expiresOn,
            };
        });
    }
}
exports.MsalAppCredentials = MsalAppCredentials;
/**
 * A reference used for Empty auth scenarios
 */
MsalAppCredentials.Empty = new MsalAppCredentials();
//# sourceMappingURL=msalAppCredentials.js.map