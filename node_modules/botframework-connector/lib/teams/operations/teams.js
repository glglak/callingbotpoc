"use strict";
/* eslint-disable prettier/prettier */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Teams = void 0;
const core_http_1 = require("@azure/core-http");
const Mappers = require("../models/teamsMappers");
const Parameters = require("../models/parameters");
const __1 = require("../");
/** Class representing a Teams. */
class Teams {
    /**
     * Create a Teams.
     *
     * @param {TeamsConnectorClientContext} client Reference to the service client.
     */
    constructor(client) {
        this.retryCount = 10;
        this.client = client;
    }
    /**
     * Fetches channel list for a given team.
     *
     * @param teamId Team Id.
     * @param options Optional. The options object to be used in every request.
     * @param callback The callback.
     * @returns A `Promise<Models.TeamsFetchChannelListResponse>`.
     */
    fetchChannelList(teamId, options, callback) {
        return this.client.sendOperationRequest({
            teamId,
            options,
        }, fetchChannelListOperationSpec, callback);
    }
    /**
     * Fetches details related to a team.
     *
     * @param teamId Team Id.
     * @param options Optional. The options object to be used in every request.
     * @param callback The callback.
     * @returns A `Promise<Models.TeamsFetchTeamDetailsResponse>`.
     */
    fetchTeamDetails(teamId, options, callback) {
        return this.client.sendOperationRequest({
            teamId,
            options,
        }, fetchTeamDetailsOperationSpec, callback);
    }
    /**
     * @param meetingId Meeting Id.
     * @param participantId Participant Id.
     * @param options The optional parameters.
     * @param callback The callback.
     * @returns Promise with TeamsFetchMeetingParticipantResponse.
     */
    fetchMeetingParticipant(meetingId, participantId, options, callback) {
        return this.client.sendOperationRequest({
            meetingId,
            participantId,
            options,
        }, fetchMeetingParticipantOperationSpec, callback);
    }
    /**
     * @param meetingId Meeting Id.
     * @param options The optional parameters.
     * @param callback The callback.
     * @returns Promise with TeamsFetchMeetingInfoResponse.
     */
    fetchMeetingInfo(meetingId, options, callback) {
        return this.client.sendOperationRequest({
            meetingId,
            options,
        }, fetchMeetingInfoOperationSpec, callback);
    }
    /**
     * @param meetingId Meeting Id.
     * @param notification The content and configuration for the notification to send.
     * @param options The optional parameters.
     * @param callback The callback.
     * @returns Promise with either MeetingNotificationResponse or an empty object.
     */
    sendMeetingNotification(meetingId, notification, options, callback) {
        return this.client.sendOperationRequest({
            meetingId,
            notification,
            options
        }, sendMeetingNotificationOperationSpec, callback);
    }
    //Batch Operations
    /**
     * Send message to a list of users.
     *
     * @param activity The activity to send.
     * @param tenantId The tenant Id.
     * @param members The list of members.
     * @param options The optional parameters.
     * @param callback The callback.
     * @returns Promise with TeamsBatchOperationResponse.
     */
    sendMessageToListOfUsers(activity, tenantId, members, options, callback) {
        const content = {
            activity,
            members,
            tenantId
        };
        return (0, __1.retryAction)(() => this.client.sendOperationRequest({
            content,
            options
        }, sendMessageToListOfUsersOperationSpec, callback), this.retryCount);
    }
    /**
     * Send message to all users belonging to a tenant.
     *
     * @param activity The activity to send.
     * @param tenantId The id of the recipient Tenant.
     * @param options The optional parameters.
     * @param callback The callback.
     * @returns Promise with TeamsBatchOperationResponse.
     */
    sendMessageToAllUsersInTenant(activity, tenantId, options, callback) {
        const content = {
            activity,
            tenantId
        };
        return (0, __1.retryAction)(() => this.client.sendOperationRequest({
            content,
            options
        }, sendMessageToAllUsersInTenantOperationSpec, callback), this.retryCount);
    }
    /**
     * Send message to all users belonging to a team.
     *
     * @param activity The activity to send.
     * @param tenantId The tenant Id.
     * @param teamId The id of the recipient Team.
     * @param options The optional parameters.
     * @param callback The callback.
     * @returns Promise with TeamsBatchOperationResponse.
     */
    sendMessageToAllUsersInTeam(activity, tenantId, teamId, options, callback) {
        const content = {
            activity,
            tenantId,
            teamId
        };
        return (0, __1.retryAction)(() => this.client.sendOperationRequest({
            content,
            options
        }, sendMessageToAllUsersInTeamOperationSpec, callback), this.retryCount);
    }
    /**
     * Send message to a list of channels.
     *
     * @param activity The activity to send.
     * @param tenantId The tenant Id.
     * @param members The list of channels.
     * @param options The optional parameters.
     * @param callback The callback.
     * @returns Promise with TeamsBatchOperationResponse.
     */
    sendMessageToListOfChannels(activity, tenantId, members, options, callback) {
        const content = {
            activity,
            tenantId,
            members
        };
        return (0, __1.retryAction)(() => this.client.sendOperationRequest({
            content,
            options
        }, sendMessageToListOfChannelsOperationSpec, callback), this.retryCount);
    }
    /**
     * Get the state of an operation.
     *
     * @param operationId The operationId to get the state of.
     * @param options The optional parameters.
     * @param callback The callback.
     * @returns Promise with BatchOperationStateResponse.
     */
    getOperationState(operationId, options, callback) {
        return (0, __1.retryAction)(() => this.client.sendOperationRequest({
            operationId,
            options
        }, getOperationStateSpec, callback), this.retryCount);
    }
    /**
     * Get the failed entries of an operation.
     *
     * @param operationId The operationId to get the failed entries of.
     * @param options The optional parameters.
     * @param callback The callback.
     * @returns Promise with BatchFailedEntriesResponse.
     */
    getOperationFailedEntries(operationId, options, callback) {
        return (0, __1.retryAction)(() => this.client.sendOperationRequest({
            operationId,
            options
        }, getPagedFailedEntriesSpec, callback), this.retryCount);
    }
    /**
     * Cancel an operation.
     *
     * @param operationId The id of the operation to cancel.
     * @param options The optional parameters.
     * @returns Promise with CancelOperationResponse.
     */
    cancelOperation(operationId, options) {
        return (0, __1.retryAction)(() => this.client.sendOperationRequest({
            operationId,
            options
        }, cancelOperationSpec), this.retryCount);
    }
}
exports.Teams = Teams;
// Operation Specifications
const serializer = new core_http_1.Serializer(Mappers);
const fetchChannelListOperationSpec = {
    httpMethod: 'GET',
    path: 'v3/teams/{teamId}/conversations',
    urlParameters: [Parameters.teamId],
    responses: {
        200: {
            bodyMapper: Mappers.ConversationList,
        },
        default: {},
    },
    serializer,
};
const fetchTeamDetailsOperationSpec = {
    httpMethod: 'GET',
    path: 'v3/teams/{teamId}',
    urlParameters: [Parameters.teamId],
    responses: {
        200: {
            bodyMapper: Mappers.TeamDetails,
        },
        default: {},
    },
    serializer,
};
const fetchMeetingParticipantOperationSpec = {
    httpMethod: 'GET',
    path: 'v1/meetings/{meetingId}/participants/{participantId}',
    urlParameters: [Parameters.meetingId, Parameters.participantId],
    queryParameters: [Parameters.tenantId],
    responses: {
        200: {
            bodyMapper: Mappers.TeamsMeetingParticipant,
        },
        default: {},
    },
    serializer,
};
const fetchMeetingInfoOperationSpec = {
    httpMethod: 'GET',
    path: 'v1/meetings/{meetingId}',
    urlParameters: [Parameters.meetingId],
    responses: {
        200: {
            bodyMapper: Mappers.TeamsMeetingInfo,
        },
        default: {},
    },
    serializer,
};
const sendMeetingNotificationOperationSpec = {
    httpMethod: 'POST',
    path: 'v1/meetings/{meetingId}/notification',
    urlParameters: [Parameters.meetingId],
    requestBody: {
        parameterPath: 'notification',
        mapper: Object.assign(Object.assign({}, Mappers.MeetingNotification), { required: true })
    },
    responses: {
        202: {
            bodyMapper: Mappers.MeetingNotificationResponse
        },
        207: {
            bodyMapper: Mappers.MeetingNotificationResponse
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    serializer
};
const sendMessageToListOfUsersOperationSpec = {
    httpMethod: 'POST',
    path: 'v3/batch/conversation/users',
    requestBody: {
        parameterPath: 'content',
        mapper: Object.assign(Object.assign({}, Mappers.BatchOperationRequest), { required: true })
    },
    responses: {
        201: {
            bodyMapper: Mappers.BatchOperationResponse
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    serializer
};
const sendMessageToAllUsersInTenantOperationSpec = {
    httpMethod: 'POST',
    path: 'v3/batch/conversation/tenant',
    requestBody: {
        parameterPath: 'content',
        mapper: Object.assign(Object.assign({}, Mappers.BatchOperationRequest), { required: true })
    },
    responses: {
        201: {
            bodyMapper: Mappers.BatchOperationResponse
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    serializer
};
const sendMessageToAllUsersInTeamOperationSpec = {
    httpMethod: 'POST',
    path: 'v3/batch/conversation/team',
    requestBody: {
        parameterPath: 'content',
        mapper: Object.assign(Object.assign({}, Mappers.BatchOperationRequest), { required: true })
    },
    responses: {
        201: {
            bodyMapper: Mappers.BatchOperationResponse
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    serializer
};
const sendMessageToListOfChannelsOperationSpec = {
    httpMethod: 'POST',
    path: 'v3/batch/conversation/channels',
    requestBody: {
        parameterPath: 'content',
        mapper: Object.assign(Object.assign({}, Mappers.BatchOperationRequest), { required: true })
    },
    responses: {
        201: {
            bodyMapper: Mappers.BatchOperationResponse
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    serializer
};
const getOperationStateSpec = {
    httpMethod: 'GET',
    path: 'v3/batch/conversation/{operationId}',
    urlParameters: [Parameters.operationId],
    responses: {
        200: {
            bodyMapper: Mappers.GetTeamsOperationStateResponse,
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    serializer,
};
const getPagedFailedEntriesSpec = {
    httpMethod: 'GET',
    path: 'v3/batch/conversation/failedentries/{operationId}',
    urlParameters: [Parameters.operationId],
    responses: {
        200: {
            bodyMapper: Mappers.GetTeamsFailedEntriesResponse,
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    serializer,
};
const cancelOperationSpec = {
    httpMethod: 'DELETE',
    path: 'v3/batch/conversation/{operationId}',
    urlParameters: [Parameters.operationId],
    responses: {
        200: {},
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    serializer,
};
//# sourceMappingURL=teams.js.map